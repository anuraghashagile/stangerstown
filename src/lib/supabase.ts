
import { createClient } from '@supabase/supabase-js';
import { Message, UserProfile } from '../types';

// Credentials injected for instant deployment
const supabaseUrl = (import.meta as any).env.VITE_SUPABASE_URL || "https://ivvglvpnryiwjdqdsvka.supabase.co";
const supabaseAnonKey = (import.meta as any).env.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml2dmdsdnBucnlpd2pkcWRzdmthIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjUxMTcxMzEsImV4cCI6MjA4MDY5MzEzMX0.RgQVnTVjptaZTArvv8OvdWxqc7rgnaQaoOhuZH4GtsA";

if (!supabaseUrl || !supabaseAnonKey) {
  console.warn("Supabase credentials missing! Chat will not work.");
}

export const supabase = createClient(
  supabaseUrl,
  supabaseAnonKey,
  {
    realtime: {
      params: {
        eventsPerSecond: 10,
      },
    },
  }
);

/* 
  --- SQL SETUP INSTRUCTIONS ---
  Run this in your Supabase SQL Editor to enable Global History and Offline Messaging:

  -- 1. Global Messages Table
  create table if not exists global_messages (
    id bigint generated by default as identity primary key,
    content text not null,
    sender_id text not null,
    sender_name text not null,
    sender_profile jsonb,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
  );
  alter table global_messages disable row level security;
  
  -- 2. Chat History / Offline Messages Table
  create table if not exists chat_history (
    id bigint generated by default as identity primary key,
    recipient_id text not null,  -- The User ID receiving the message
    sender_id text not null,     -- The User ID sending the message
    content text,
    type text not null,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
  );
  alter table chat_history disable row level security;
*/

// --- GLOBAL MEET FUNCTIONS ---

export const getGlobalMessages = async (): Promise<any[]> => {
  try {
    const { data, error } = await supabase
      .from('global_messages')
      .select('*')
      .order('created_at', { ascending: false })
      .limit(50);

    if (error) {
      console.warn("History fetch failed:", error.message);
      return [];
    }
    return data || [];
  } catch (err) {
    return [];
  }
};

export const insertGlobalMessage = async (text: string, userProfile: UserProfile, peerId: string) => {
  try {
    const { error } = await supabase.from('global_messages').insert({
      content: text,
      sender_id: peerId,
      sender_name: userProfile.username,
      sender_profile: userProfile
    });

    if (error) {
      console.warn("DB Insert Failed (using broadcast only):", error.message);
      return { error };
    }
    return { error: null };
  } catch (e) {
    console.warn("DB Exception:", e);
    return { error: e };
  }
};

// --- OFFLINE MESSAGING FUNCTIONS ---

export const sendOfflineMessage = async (recipientId: string, senderId: string, message: Message) => {
  try {
    const { error } = await supabase.from('chat_history').insert({
      recipient_id: recipientId,
      sender_id: senderId,
      content: message.fileData || message.text, // Store text or base64
      type: message.type
    });
    
    if (error) console.warn("Offline send failed:", error.message);
  } catch (e) {
    console.warn("Offline send exception:", e);
  }
};

export const fetchOfflineMessages = async (myPeerId: string): Promise<any[]> => {
  try {
    // Get messages sent TO me
    const { data, error } = await supabase
      .from('chat_history')
      .select('*')
      .eq('recipient_id', myPeerId)
      .order('created_at', { ascending: true })
      .limit(50);

    if (error) return [];
    
    // Optional: Delete fetched messages so they don't appear again? 
    // For now, we keep them as history.
    
    return data || [];
  } catch (e) {
    return [];
  }
};

// --- LEGACY HISTORY (Optional) ---
export const saveMessageToHistory = async (userId: string, message: Message) => {
  // Logic moved to sendOfflineMessage mostly, but keeping for compatibility if needed
};

export const fetchChatHistory = async (userId: string): Promise<Message[]> => {
  return [];
};
